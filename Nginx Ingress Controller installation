git clone https://github.com/nginxinc/kubernetes-ingress.git --branch v3.3.1
cd kubernetes-ingress/
cd deployments/

1. Configure RBAC

kubectl apply -f common/ns-and-sa.yaml
kubectl apply -f rbac/rbac.yaml
kubectl apply -f rbac/ap-rbac.yaml
kubectl apply -f rbac/apdos-rbac.yaml
kubectl apply -f common/nginx-config.yaml
kubectl apply -f common/ingress-class.yaml

2. Create Custom Resources

kubectl apply -f common/crds/k8s.nginx.org_virtualservers.yaml
kubectl apply -f common/crds/k8s.nginx.org_virtualserverroutes.yaml
kubectl apply -f common/crds/k8s.nginx.org_transportservers.yaml
kubectl apply -f common/crds/k8s.nginx.org_policies.yaml
kubectl apply -f common/crds/k8s.nginx.org_globalconfigurations.yaml
kubectl apply -f common/crds/appprotect.f5.com_aplogconfs.yaml
kubectl apply -f common/crds/appprotect.f5.com_appolicies.yaml
kubectl apply -f common/crds/appprotect.f5.com_apusersigs.yaml
kubectl apply -f common/crds/appprotectdos.f5.com_apdoslogconfs.yaml
kubectl apply -f common/crds/appprotectdos.f5.com_apdospolicy.yaml
kubectl apply -f common/crds/appprotectdos.f5.com_dosprotectedresources.yaml

3. Let's Deploy

cd deployment/
kubectl create -f nginx-ingress.yaml
kubectl get deploy -n nginx-ingress
kubectl get pod -n nginx-ingress -o wide

root@new-cluster:~# kubectl get pod -n nginx-ingress -o wide
NAME                             READY   STATUS    RESTARTS   AGE     IP              NODE     NOMINATED NODE   READINESS GATES
nginx-ingress-77c5455c5b-cp6q4   1/1     Running   0          27m     192.168.13.64   node-1   <none>           <none>
nginx-ingress-97cc58d9d-26bv7    0/1     terminating   0          4m18s   <none>          <none>   <none>           <none>
root@new-cluster:~#


Note: Here you will se that pod has taken ip from the Claico switch so Now in order to expose this ingress controller deployment we have two options.
1. either we can create a service ip and nodeport or
2. we can directly edit our deployment with "hostNnetwork: true" so that this pod will take Node IP. 

4. kubectl edit deploy -n nginx-ingress   //I am following Option 2.

so now lets edit the nginx ingress deployment and add the "hostNnetwork: true" so that nginx pod will take the node ip that you can directly bind with the ELB (Elastic Load Balancer).
---------
    spec:
      hostNnetwork: true     //add this line,  
      automountServiceAccountToken: true
      containers:
      - args:
        - -nginx-configmaps=$(POD_NAMESPACE)/nginx-config
        env:
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              apiVersion: v1
              fieldPath: metadata.namespace
        - name: POD_NAME
------------------------
Now Pod has taken the Ip of Node-1 so yo can directoy map this with AWS ELB.
root@new-cluster:~# kubectl get po -n nginx-ingress -o wide
NAME                             READY   STATUS    RESTARTS   AGE     IP              NODE     NOMINATED NODE   READINESS GATES
nginx-ingress-77c5455c5b-cp6q4   1/1     Running   0          25m     172.31.28.102   node-1   <none>           <none>
nginx-ingress-97cc58d9d-26bv7    0/1     Pending   0          2m46s   <none>          <none>   <none>           <none>
root@new-cluster:~#

---------
FAQ:
1. What if this nginx ingress pod get created in node-2 as pods are emortal.
Ans: We can assign a node Selector.
1. first give a label to your node-1.
root@new-cluster:~# kubectl label node node-1 role=ingress
root@new-cluster:~# kubectl get node --show-labels
NAME          STATUS   ROLES           AGE   VERSION   LABELS
new-cluster   Ready    control-plane   26d   v1.28.2   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=new-cluster,kubernetes.io/os=linux,node-role.kubernetes.io/control-plane=,node.kubernetes.io/exclude-from-external-load-balancers=
node-1        Ready    <none>          25d   v1.28.2   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=node-1,kubernetes.io/os=linux,role=ingress
node-2        Ready    <none>          23d   v1.28.2   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=node-2,kubernetes.io/os=linux
---------------------
root@new-cluster:~# kubectl edit deploy nginx-ingress -n nginx-ingress
    spec:
      nodeSelector:          //add these two lines 
            role: ingress
      automountServiceAccountToken: true
      containers:
      - args:
        - -nginx-configmaps=$(POD_NAMESPACE)/nginx-config
        env:
        - name: POD_NAMESPACE
          valueFrom:
------------------------------
Now we have assign nodeSelector so pod will be always created in Node-1.

